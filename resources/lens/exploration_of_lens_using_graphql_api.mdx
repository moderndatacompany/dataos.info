---
title: "GraphQL API"
---

<Info>
  For a more streamlined and interactive experience with GraphQL, use the GraphQL playground on Data Product Hub. This interface simplifies interactions and eliminates the need to manually work with tools like curl. [Access the GraphQL guide here](/interfaces/data_product_hub/activation/app_development/).
</Info>

This guide provides comprehensive instructions for accessing and interacting with the Lens GraphQL API. You can interact with the Lens GraphQL API using:

1. [**Explorer Studio in Data Product Hub**](#using-explorer-studio-in-data-product-hub): An interactive in-browser tool for writing and executing GraphQL queries.

2. [**Curl**](#using-curl): A command-line tool for transferring data with URLs, useful for automated scripts.

3. [**Python**](#using-python): Use Python's `requests` library for more complex interactions with the API.

4. [**Postman**](#using-postman): Use Postman API platform to start using and testing REST APIs.

## Authentication and Authorization

To securely interact with the Lens GraphQL API, you must authenticate your requests using a DataOS API key and ensure proper user group configurations. This section explains how to generate an API key and configure user groups to access the API.

### **Generating a DataOS API Key**

To authenticate API requests, you need a DataOS API key. This key validates your identity and ensures only authorized users can access and query the data.

**Steps to Generate an API Key:**

* Open your terminal and run the following command to create a new API key:

```bash
dataos-ctl user apikey create
```

* To view existing API keys, use:

```bash
dataos-ctl user apikey get
```

* Note down your API key and keep it secure. You will use this key to authenticate your API requests.

API key tokens can also be fetched from the DataOS GUI, for more details refer to the [documentation here](/interfaces/#create-tokens).

### **Configuring user groups**

To access and query data through the GraphQL endpoint, users need to belong to a user group that has the appropriate permissions. These permissions are granted through the `api_scopes` attribute in the user group configuration, which can be found in the Lens directory. Each user group defines the API scopes (such as meta, data, source, or graphql) that determine the access level for various API endpoints.

**Example user group configuration**

The following YAML configuration demonstrates how to set up user groups with different levels of access:

```yaml
user_groups:
  # User group with full access to GraphQL API and data querying capabilities
  - name: engineer
    description: Data Analyst
    api_scopes:
      - meta      # For accessing metadata
      - graphql   # For accessing the GraphQL API
      - data      # For querying the data
    includes:
      - users:id:exampleuser

  # User group with access to GraphQL API but no data querying capabilities
  - name: analyst
    description: Data Engineer
    api_scopes:
      - meta
      - graphql
    includes:
      - users:id:testuser

  # User group without access to GraphQL API or data querying capabilities
  - name: testuser
    description: Data Engineer
    api_scopes:
      - meta
    includes:
      - users:id:testuser
```

**Explanation of the Configuration:**

* **`engineer` Group:** This group can access the GraphQL API and query data because it includes both the `graphql` and `data` `api_scopes`.

* **`analyst` Group:** This group can access the GraphQL API but cannot query the data because the `data` scope is missing.

* **`testuser` Group:** This group cannot access the GraphQL API or query data because both the `graphql` and `data` scopes are missing.

<Note>
  The user groups configured above only manage access permissions at the consumption level within DataOS. However, source-level permissions defined by the source administrator (e.g., in Snowflake or BigQuery) remain applicable. For sources accessible through the DataOS Query Engine (Minerva/Themis), you can define source-level permissions using the [Bifrost](/interfaces/bifrost/) application in the DataOS GUI or using the [Policy](/resources/policy/) and [Grant](/resources/grant/) Resource using DataOS CLI.
</Note>

## How to access the GraphQL API?

### **Using Explorer Studio in Data Product Hub**

The Explorer Studio of Data Product Hub provides an intuitive, in-browser interface to interact with the GraphQL API.

* **Open Metis:** Go to the Metis application on the DataOS GUI and navigate to the Resource section here click on Lens choose the desired deployed Lens model.

<div>
  <img src="/resources/lens/consumption_of_deployed_lens/graphql/graphql1.png" alt="graphql" />
</div>

* **Access GraphQL Tab:** Click on the ‘Explore in Studio’ button, the Studio will appear from here navigate to the GraphQL tab.

<div>
  <img src="/resources/lens/consumption_of_deployed_lens/graphql/graphql2.png" alt="graphql" />
</div>

* **Compose a Query:** Enter your GraphQL query in the left pane.

<div>
  <img src="/resources/lens/consumption_of_deployed_lens/graphql/graphql3.png" alt="graphql" />
</div>

* You can press `Ctrl + Space` to bring up the autocomplete window. For example:

```graphql
query LensQuery {
    table {
      wallet_sales_view {
      revenue
    }
    }
  }
```

* **Execute the Query:** Click the 'Execute' button or press `Ctrl + Enter` to run the query. The results will appear in the right pane.

```graphql
{
   "data": {
       "table": [
           {
               "wallet_sales_view": {
                   "revenue": 77835071
               }
           }
       ]
   }
}
```

### **Using Curl**

Curl is a command-line tool used for transferring data with URLs, making it a convenient choice for interacting with APIs directly from the terminal. Ensure that `curl` is installed on your system before proceeding.

**Prepare the Request:** To send a GraphQL query using Curl, construct your request with the following template:

<CodeGroup>
  ```bash Syntax
  curl -X POST <URL> \
  -H "Content-Type: application/json" \
  -H "apikey: <DATAOS_API_KEY>" \
  -d '{"query": "<GRAPHQL_QUERY>"}'
  ```

  ```bash Example
  curl -X POST https://alpha-omega.dataos.app/lens2/api/public:lakehouse-insights01/v2/graphql \
  -H "Content-Type: application/json" \
  -H "apikey: abcdefghijklmnopqrstuvwxyz" \
  -d '{"query": "query LensQuery { table { total_operations { lakehouse_insights_total_data_size_in_gb lakehouse_insights_table_name } } }"}'
  ```
</CodeGroup>

**Replace `<URL>` with the appropriate endpoint based on your environment**:

```bash
https://<DATAOS_FQDN>/lens2/api/<WORKSPACE>:<NAME_OF_LENS>/v2/graphql
```

**Replace `<DATAOS_API_KEY>`with your actual DataOS API key:** Refer to the \[Generating an API Key]\(#generating-an-api-key) section for more information on obtaining an API key.

* **Replace `<DATAOS_FQDN>` with the fully qualified domain name of your DataOS instance:** For example: \`alpha-omega.dataos.app\` or \`happy-kangaroo.dataos.app\`.

* **Replace `<WORKSPACE>` with the DataOS Workspace name where the Lens is deployed:** This is typically the name of the DataOS Workspace where the Lens is deployed. For example: `public`, `sandbox`, etc.

* **Replace `<NAME_OF_LENS>` with the name of your deployed Lens model:** This corresponds to the specific Lens model you want to query.

* **Replace `<GRAPHQL_QUERY>` with your GraphQL query:**  Format the query as a valid JSON string.

**Execute the Command:**  Run the command in your terminal to execute the query and view the response.

<Note>
  Ensure you replace the placeholders with the actual values specific to your environment. Properly formatted queries and valid API keys are essential for successful API interactions.
</Note>

### **Using Postman**

When working with a Postman collection to test APIs, you typically need to configure authorization, set request methods, and provide the request body. Below are the steps to get started:

**Open Postman and import the Postman collection:**

1. Open Postman and click on the **Import** button located at the top-left corner.

2. Import the Postman Collection file you’ve been given. For example, if you import the Lens API collection from the provided link, you will see a collection of API requests neatly organized into folders. Refer to the below image for subsequent steps.

![postman](https://dataos.info/resources/lens/exploring_deployed_lens_using_rest_apis/Untitled1.png "Postman")

**Set up Authorization (bearer token):**

1. Once the collection is imported, click on the specific API request you want to test.

2. Go to the **Authorization** tab.

3. From the **Auth Type** dropdown, select **Bearer Token**.

4. In the Token field, paste your Bearer token, which you have received from your authentication process.

5. This token grants you access to the meta and data scopes.

**Set the Request type:** Select the API request type as `POST` from the dropdown next to the API URL.

**Prepare the URL and Query the API:**  Prepare the URL according to what data you want to fetch.

```bash

https://<DATAOS_FQDN>/lens2/api/<WORKSPACE>:<NAME_OF_LENS>/v2/graphql
```

* **Replace `<DATAOS_API_KEY>` with your actual DataOS API key.** Refer to the [Generating an API Key](https://dataos.info/resources/lens/exploration_of_deployed_lens_using_graphql/#generating-an-api-key) section for more information on obtaining an API key.

* **Replace `<DATAOS_FQDN>` with the fully qualified domain name of your DataOS instance.** For example: `alpha-omega.dataos.app` or `happy-kangaroo.dataos.app`.

* **Replace `<WORKSPACE>` with the workspace name associated with your Lens model.** This is typically the name of the DataOS Workspace where the Lens is deployed. For example: `public`, `sandbox`, etc.

* **Replace `<NAME_OF_LENS>` with the name of your deployed Lens model.** This corresponds to the specific Lens model you want to query. For e.g. `sales360`.

* **Replace `<QUERY>` with the specific fields you want to query from schema.** Make sure to format the query string as valid JSON.

**Set the Request Body in Postman (for POST Methods):** for `POST` requests, you must configure the Body tab for graphql. Refer to the below image for subsequent steps.
![graphql](https://dataos.info/resources/lens/exploring_deployed_lens_using_rest_apis/graphql.png)
*Postman GraphQL request body tab*

* In the `Body` tab, select `GraphQL` from the format options.

* Enter the GraphQL query in the provided field in the following format.&#x20;

* Replace the table name and choose the required dimensions and measures. For instance,  to compare the average price and average margin of two major categories: Apparel and Footwear for the `products` table. The request body will be as shown in the below example:

<CodeGroup>
  ```graphql Syntax
  query <QueryName> {
    table(limit: <int>, offset: <int> timezone:<>) {
      <TABLE1_NAME> {
        <DIMENSION>
        <MEASURE_1>
        <MEAUSRE_2>
      }
      <TABLE2_NAME>
    }
   }
  ```

  ```graphql Example
  query LensQuery {
    table(limit: 10, offset: 0) {
      products {
        productcategory
        average_price
        average_margin
      }
    }
  }
  ```
</CodeGroup>

## GraphQL API Reference

### **`table`**

```graphql
query {
  Table [([TableQueryArgs])] {
    <TableName> [([TableArgs])] {
      <TableMember>
    }
  }
}
```

| Key            | Schema         | Description                                 |
| -------------- | -------------- | ------------------------------------------- |
| TableQueryArgs | TableQueryArgs | Options that apply to the entire query      |
| TableArgs      | TableArgs      | Options that apply only to a specific table |

### **tableQueryArgs**

* **`limit` (`Int`):** A [row limit](https://cube.dev/docs/product/apis-integrations/queries#row-limit) for your query.

* **`offset` (`Int`):** The number of initial rows to be skipped for your query. The default value is `0`.

* **`timezone` (`String`):** The [time zone](https://cube.dev/docs/product/apis-integrations/queries#time-zone) for your query. You can set the desired time zone in the [TZ Database Name(opens in a new tab)](https://en.wikipedia.org/wiki/Tz_database) format, e.g., `America/Los_Angeles`.

### **tableArgs**

| Key       | Schema                                  | Description                                                                                                                                                                                                                                  |
| --------- | --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`   | [`TableWhereInput`](#table-where-input) | The 'where' clause conditions specify the logical operators and filters you can use inside the where argument to refine your query. It uses logical operators like `AND`, `OR`  and to [filter](#filters) the specific table member filters. |
| `orderBy` | `TableOrderByInput`                     | The `orderBy` clause specifies how to sort the query results. You can use it to sort by specific table members (fields/columns) in either ascending or descending order.                                                                     |

### **`tableWhereInput`**

| Key             | Schema              | Description                                                                                                                                                                                                   |
| --------------- | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `AND`           | `[RootWhereInput!]` | The `AND` condition allows you to combine multiple filter conditions. All conditions within this group must be true for the query to return results.                                                          |
| `OR`            | `[RootWhereInput!]` | The `OR` condition allows you to combine multiple filter conditions. At least one condition within this group must be true for the query to return results.                                                   |
| `<tableMember>` | [`Filter`](#filter) | Represents a filter for a specific member (field) of the table. You can use different filter types like `DateTimeFilter`, `FloatFilter`, and `StringFilter` to refine results based on specific field values. |

### **`tableOrderByInput`**

| Key             | Schema                 | Description |
| --------------- | ---------------------- | ----------- |
| `<tableMember>` | [`OrderBy`](#order-by) |             |

### **Filters**

These filters are used within the `where` clause to refine query results based on different data types like `DateTime`, `Float`, and `String`.

[`DateTimeFilter`](#date-time-filter) | [`FloatFilter`](#float-time-filter) |
[`StringFilter`](#string-time-filter)

### **`datetime` filter**

| Key              | Schema     | Description                                      |
| ---------------- | ---------- | ------------------------------------------------ |
| `equals`         | `String`   | Matches exactly the specified datetime string.   |
| `notEquals`      | `String`   | Does not match the specified datetime string.    |
| `in`             | `[String]` | Matches any datetime from the list of values.    |
| `notIn`          | `[String]` | Does not match any datetime from the list.       |
| `inDateRange`    | `[String]` | Matches datetime values within the given range.  |
| `notInDateRange` | `[String]` | Excludes datetime values within the given range. |
| `beforeDate`     | `String`   | Matches any datetime before the specified date.  |
| `afterDate`      | `String`   | Matches any datetime after the specified date.   |
| `set`            | `Boolean`  | Indicates if the datetime field is set.          |

### **`float` filter**

| Key         | Schema    | Description                                   |
| ----------- | --------- | --------------------------------------------- |
| `equals`    | `Float`   | Matches exactly the specified float value.    |
| `notEquals` | `Float`   | Does not match the specified float value.     |
| `in`        | `[Float]` | Matches any float value from the list.        |
| `notIn`     | `[Float]` | Does not match any float value from the list. |
| `set`       | `Boolean` | Indicates if the float field is set.          |

### **`string` filter**

| Key           | Schema     | Description                                              |
| ------------- | ---------- | -------------------------------------------------------- |
| `equals`      | `String`   | Matches exactly the specified string value.              |
| `notEquals`   | `String`   | Does not match the specified string value.               |
| `in`          | `[String]` | Matches any string value from the list.                  |
| `notIn`       | `[String]` | Does not match any string value from the list.           |
| `contains`    | `String`   | Matches strings that contain the specified value.        |
| `notContains` | `String`   | Does not match strings that contain the specified value. |
| `set`         | `Boolean`  | Indicates if the string field is set.                    |

## **orderBy**

`asc` | `desc`

## GraphQL Query Examples

This section provides sample GraphQL queries that you can use directly in Explorer Studio of the Data Product Hub. You can also use these queries with the placeholder in the Curl and Python methods described earlier.

### **Querying a dimension**

A GraphQL query to retrieve the `city` dimension associated with an `account` table might look something like this:

<CodeGroup>
  ```json Query
  query LensQuery {
      table {
      account {
        city
      }
      }
    }
  ```

  ```json Response
  {
    "data": {
      "table": [
        {
          "account": {
            "city": "Los Angeles",
            "total_accounts": 59
          }
        }
        ...
        {
          "account": {
            "city": "Columbus",
            "total_accounts": 1
          }
        }
      ]
    }
  }
  ```
</CodeGroup>

### **Specifying  filters**

Filters can be set on the load query or on a specific table. Specifying the filter on the load query applies it to all tables in the query. Filters can be added to the query as follows:

```
query LensQuery {
    table{
    account(
      where: { premise_code: { equals: "OFF" } }
    ) {
      total_accounts
      city
      premise_code
    }
  }
}
```

## Date filter

This filter ensures that only records with `birth_date` values within the specified range, between `"1955-01-01"` and `"1955-03-03"`, are returned.

```
query LensQuery { 
  table(limit: 10) { 
    customers(
      where: { birth_date: { inDateRange: ["1955-01-01", "1955-03-03"] } }
    ) {
      customer_name
      marital_status
      customer_key
    } 
  }
}
```

##

### **Time dimension granularity**

The granularity for a time dimension can easily be changed by specifying it in the query:

<Info>
  To ensure the correct granularity results of the date, make sure the date is cast to a timestamp format when loading the data into SQL, as granularity works only on columns with a timestamp format.
</Info>

```
query LensQuery {
  table {
    sales {
      invoice_date {
        month
      }
    }
  }
}
```

Any supported granularity can be used. If you prefer to not specify a granularity, then use `value`:

```
query LensQuery {
  table {
    sales {
      invoice_date {
        value
      }
    }
  }
}
```

###

**Specifying order by condition and limiting the result**

A GraphQL query that specifies an order by condition and limits the number of results returned would look like this:

<CodeGroup>
  ```graphql Query
  query LensQuery {
      table(limit: 10) {
      account(
        orderBy: { total_accounts: desc}
      ) {
        total_accounts
        city
        premise_code
      }
    }
  }
  ```

  ```json Response
  console.log("He{
    "data": {
      "table": [
        {
          "account": {
            "total_accounts": 27,
            "city": "Los Angeles",
            "premise_code": "ON"
          }
        },
        {
          "account": {
            "total_accounts": 25,
            "city": "Los Angeles",
            "premise_code": "OFF"
          }
        },
        {
          "account": {
            "total_accounts": 9,
            "city": "Chicago",
            "premise_code": "OFF"
          }
        },
        {
          "account": {
            "total_accounts": 7,
            "city": "Los Angeles",
            "premise_code": "BOTH"
          }
        },
        {
          "account": {
            "total_accounts": 5,
            "city": "Houston",
            "premise_code": "OFF"
          }
        },
        {
          "account": {
            "total_accounts": 5,
            "city": "New York",
            "premise_code": "OFF"
          }
        },
        {
          "account": {
            "total_accounts": 5,
            "city": "San Francisco",
            "premise_code": "OFF"
          }
        },
        {
          "account": {
            "total_accounts": 4,
            "city": "Greenville",
            "premise_code": "ON"
          }
        },

      ]
    }
  }
  ```
</CodeGroup>

### **Querying multiple tables**

Using the same `account` table as before, let’s try and get the revenue for each. We can do this by adding the `sales` table to our query as follows:

<CodeGroup>
  ```graphql Query
  query LensQuery {
      table{
      account{
        total_accounts
        city
        premise_code
      }
      sales{
        revenue
      }
    }
  }
  ```

  ```
  {
    "data": {
      "table": [
        {
          "account": {
            "total_accounts": 26,
            "city": "Los Angeles",
            "premise_code": "ON"
          },
          "sales": {
            "revenue": 3911966
          }
        },
        {
          "account": {
            "total_accounts": 25,
            "city": "Los Angeles",
            "premise_code": "OFF"
          },
          "sales": {
            "revenue": 10562513
          }
        },
        {
          "account": {
            "total_accounts": 7,
            "city": "New York",
            "premise_code": "BOTH"
          },
          "sales": {
            "revenue": 937897
          }
        },
        {
          "account": {
            "total_accounts": 5,
            "city": "Chicago",
            "premise_code": "OFF"
          },
          "sales": {
            "revenue": 3206423
          }
        }
      ]
    }
  }
  ```

  ```
  {
    "data": {
      "table": [
        {
          "account": {
            "total_accounts": 26,
            "city": "Los Angeles",
            "premise_code": "ON"
          },
          "sales": {
            "revenue": 3911966
          }
        },
        {
          "account": {
            "total_accounts": 25,
            "city": "Los Angeles",
            "premise_code": "OFF"
          },
          "sales": {
            "revenue": 10562513
          }
        },
        {
          "account": {
            "total_accounts": 7,
            "city": "New York",
            "premise_code": "BOTH"
          },
          "sales": {
            "revenue": 937897
          }
        },
        {
          "account": {
            "total_accounts": 5,
            "city": "Chicago",
            "premise_code": "OFF"
          },
          "sales": {
            "revenue": 3206423
          }
        }
      ]
    }
  }
  ```
</CodeGroup>

To view the examples of GraphQL queries, please click [here](/resources/lens/query_format/).